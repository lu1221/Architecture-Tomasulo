==========

The following gives a brief description of our underlying design principle.

==========

The run_Tomasolu( .. ) function loops through calling CDB, execute, issue, and dispatch each cycle, until simulation is complete. Please refer to comments in tomasolu.c for further explanation.

Dispatch
    The dispatch stage includes both instruction fetch and dispatch. It is implementated in function fetch_To_dispatch( .. ).
    Fetch
        In this stage we used get_instr( .. ) to fetch one instruction into an  instruction fetch queue of size 10 to store for each clock cycle. We used our helper function ifq_not_ful( .. ) to determine the status of the fetch queue: 
            1. The fetched instruction is NULL we simply return as it signified the end of the trace execution.
            2. If the fetched instruction is a TRAP instruction we skip it and fetch the next instruction in the same cycle.
            3. In case the fetch queue is full we just fetch nothing and simply return.
            4. In case the fetch queue is not full we fetch one instruction and put it to the end of the queue.
        At the same time we initiatialize instruction attributes including Q[i]s and tom_*_cycles. We also increment the instruction queue size by one.
    
    Dispatch: We attempted to get the instruction from the head of the IFQ and dispatch into the corresponding reservation stations depending on the instruction if it is an integer or floating-point computation . We used our helper function rs_not_full( .. ) to determine whether or not the reservation station is full.
            1. If the fetched instruction is a conditional or unconditional control instruction i.e. a branch in this case we poped this instruction off the queue and shift the queue using our helper function shift_ifq(void).
            2. In case the reservation station is full we simply return i.e. this is essentially a stall due to structural hazard. 3. In case the reservation station is not full we located the free reservation station indicated by rs_not_full( .. ) and placed the instruction into the slot. 4. We then check RAW hazards by checking the entries of the map table to see if it corresponds to the source registers used in the current instruction. If we do find such an entry, then we know that there is a RAW hazard dependency. And we link the instruction that produces the result needed by the source register in the current instruction to the source register of the current instruction  i.e. curr_instr->Q[ .. ] = map_table[ curr_instr->r_in[i] ]. We then updated the map table to link the current instruction's output register(s) to the reservation station where it resides. Finally we update the dispatch cycle, tom_dispatch_cycle associated with the current instruction and shift the IFQ.
